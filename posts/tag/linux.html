<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
        <title>Michal Zimmermann | tag: linux</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel="stylesheet">
        <link href="https://www.zimmi.cz/posts/atom.xml" type="application/atom+xml" rel="alternate" title="Michal Zimmermann Full Atom Feed" />
        <link href="https://www.zimmi.cz/posts/feed.xml" type="application/rss+xml" rel="alternate" title="Michal Zimmermann Full RSS Feed" />
        <link rel="stylesheet" href="https://www.zimmi.cz/posts/theme/css/style.min.css?9908e745">
</head>
<body>
    <nav role="navigation">
        <ul>
            <li><a href="https://www.zimmi.cz/posts/categories">Categories</a></li>
            <li><a href="https://www.zimmi.cz/posts/tags">Tags</a></li>
            <li><a href="https://www.zimmi.cz/posts/feed.xml">Subscribe to RSS feed</a></li>
            <li>
                <form class="search" name="x" action="//duckduckgo.com/" target="_blank">
                    <input type="hidden" value="zimmi.cz/posts" name="sites" />
                    <input class="search-input" type="search" placeholder="Search" name="q" />
                    <input class="button" type="submit" value="Go" />
                </form>
            </li>
        </ul>
    </nav>
    <header>
        <h1><a href="/posts">Michal Zimmermann<small>Pieces of knowledge from the world of GIS.</small></a></h1>
    </header>
    <main>
<h2 class="text-center">Articles tagged with linux tag</h2>

<article>
    <h1><a href="https://www.zimmi.cz/posts/2018/postgresql-backup-and-recovery-orchestration-systemd-automation/" rel="bookmark" title="Permalink to PostgreSQL Backup and Recovery Orchestration: systemd Automation">PostgreSQL Backup and Recovery Orchestration: systemd&nbsp;Automation</a></h1>
    <aside><span>Apr 10, 2018</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p>Posts in this series have described the basic automation of PostgreSQL backup/recovery strategy. The process itself consists of different periodic tasks that shouldn&#8217;t be executed manually. There are essentially two tools dedicated to periodic task running in Linux: <strong>cron</strong> and <strong>systemd</strong>.</p>
<p>Cron used to be my first choice of automation in Linux, as it&#8217;s very easy to use. On the other hand, it&#8217;s quite messy (running <code>crontab -e</code> under different users to find out which one has the job defined) and a bit difficult to test - many times I ran into a situation when underlying bash script executed just fine, while cron job kept failing for reason&nbsp;unknown.</p>
<p>My own cron experience together with a few words from a workmate brought me into the arms of systemd, which is a Linux system and service manager. It&#8217;s capable of running periodic tasks just like cron, yet making it more&nbsp;transparent.</p>
<h2>Important&nbsp;bits</h2>
<p>Understanding the whole systemd is way out of scope of a poor <span class="caps">GIS</span> guy, yet I managed to tame three important parts of the&nbsp;ecosystem:</p>
<ul>
<li>services</li>
<li>timers</li>
<li>targets</li>
</ul>
<h3>Services</h3>
<p>Service is a configuration saved inside &#8220;.service&#8221; file specifying what you want systemd to do. Following code shows how you can tell systemd to vacuum your database once in a&nbsp;while.</p>
<div class="highlight"><pre><span></span><span class="o">[</span>Unit<span class="o">]</span>
<span class="nv">Description</span><span class="o">=</span>CR vacuumdb
<span class="nv">OnFailure</span><span class="o">=</span>unit-status-mail@%n.service unit-status-slack@%n.service
<span class="nv">Wants</span><span class="o">=</span>cr-sunday.timer

<span class="o">[</span>Service<span class="o">]</span>
<span class="nv">User</span><span class="o">=</span>postgres
<span class="nv">Group</span><span class="o">=</span>postgres
<span class="nv">Type</span><span class="o">=</span>simple
<span class="nv">ExecStart</span><span class="o">=</span>/bin/bash /usr/local/sbin/pgsql-vacuumdb.sh --port %i

<span class="o">[</span>Install<span class="o">]</span>
<span class="nv">WantedBy</span><span class="o">=</span>cr-sunday.target
</pre></div>


<p>Unit files come with several handy features. First of all, they are orchestrated with <code>systemctl</code>. Second, any service configuration file containing <code>@</code> in its filename might be symlinked/copied and run for different instances. Third, notice <code>OnFailure</code> directive in the code above. If anything goes wrong, systemd might serve as a postman delivering the bad news. I set up both e-mail and Slack notifications and they&#8217;ve been working like a charm ever&nbsp;since.</p>
<p>On top of that, I find systemd orchestration much easier to test and maintain compared to&nbsp;cron.</p>
<p>With the above code saved in <code>/lib/systemd/system/pgsql-vacuumdb@.service</code>, you can copy the file to <code>/lib/systemd/system/pgsql-vacuumdb@5432.service</code>, <code>/lib/systemd/system/pgsql-vacuumdb@5432.service</code> etc. If you look at <code>ExecStart</code> part of the service file, you&#8217;ll notice <code>%i</code> being used at the end - a <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">placeholder</a> replaced with the string between <code>@</code> and <code>.service</code> in the&nbsp;filename.</p>
<p>This systemd service file is no more than a simple wrapper around the following bash code. We run three different database clusters on one machine and this approach makes their maintenance pretty&nbsp;comfortable.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># @author: Michal Zimmermann &amp;lt;michal.zimmermann@clevermaps.cz&amp;gt;</span>
<span class="c1"># Vacuums the whole database cluster running on a given port.</span>

<span class="k">while</span> <span class="o">[[</span> <span class="nv">$#</span> <span class="p">&amp;</span>gt<span class="p">;</span> <span class="m">0</span> <span class="o">]]</span>
<span class="k">do</span>
    <span class="nv">key</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

    <span class="k">case</span> <span class="nv">$key</span> in
        -p<span class="p">|</span>--port<span class="o">)</span>
            <span class="nv">PORT</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$2</span><span class="s2">&quot;</span>
            <span class="nb">shift</span>
            <span class="p">;;</span>
        *<span class="o">)</span>
            <span class="nb">echo</span> <span class="s2">&quot;Usage: `basename </span><span class="nv">$0</span><span class="s2">` --port|-p [port_number]&quot;</span>
            <span class="nb">exit</span> <span class="m">1</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
    <span class="nb">shift</span>
<span class="k">done</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="nv">$PORT</span><span class="s2">&quot;</span> <span class="o">]]</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Port not provided!&quot;</span>
    <span class="nv">$0</span> *
    <span class="nb">exit</span> <span class="m">2</span>
<span class="k">fi</span>

/usr/bin/vacuumdb -U postgres -p <span class="nv">$PORT</span> --all --full --analyze
</pre></div>


<p>What you get so far is the possibility to run <code>systemctl start pgsql-vacuumdb@5432</code> instead of calling the underlying bash code manually. Not much, really. That&#8217;s where timers come to the&nbsp;party.</p>
<h3>Timers</h3>
<p>Timer files ends with &#8220;.timer&#8221; and are responsible for running services on given time. The code below, coming from <code>/lib/systemd/system/cr-sunday.timer</code> file runs the <code>pgsql-vacuumdb</code> service every Sunday at 3:45&nbsp;am.</p>
<div class="highlight"><pre><span></span><span class="o">[</span>Unit<span class="o">]</span>
<span class="nv">Description</span><span class="o">=</span>CR Sunday timer

<span class="o">[</span>Timer<span class="o">]</span>
<span class="nv">OnCalendar</span><span class="o">=</span>Sun *-*-* <span class="m">03</span>:45
<span class="nv">Persistent</span><span class="o">=</span>yes
<span class="nv">Unit</span><span class="o">=</span>cr-sunday.target

<span class="o">[</span>Install<span class="o">]</span>
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</pre></div>


<h3>Targets</h3>
<p>Target files end with &#8220;.target&#8221; and are used to group units in general. In our case, the target file for vacuumdb service is as simple as the following&nbsp;code.</p>
<div class="highlight"><pre><span></span><span class="o">[</span>Unit<span class="o">]</span>
<span class="nv">Description</span><span class="o">=</span>CR Sunday target
<span class="nv">StopWhenUnneeded</span><span class="o">=</span>yes
</pre></div>


<p>Targets might be called by other targets. Running <code>systemctl start cr-sunday.target</code> would eventually lead to running all the services wanted by that&nbsp;target.</p>
<p>As I already mentioned, I find systemd services easy to code and test. If any of them should fail, you&#8217;d find a message in syslog or via <code>systemctl status pgsql-vacuumdb</code>.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2018/postgresql-backup-and-recovery-orchestration-bash-automation/" rel="bookmark" title="Permalink to PostgreSQL Backup and Recovery Orchestration: Bash Automation">PostgreSQL Backup and Recovery Orchestration: Bash&nbsp;Automation</a></h1>
    <aside><span>Mar 2, 2018</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p>There is a bunch of periodic database-related tasks in a life of PostgreSQL administrator. Some should be done daily, others weekly, others can wait for a whole month. Many of them are essential for your database health. Forget to run such a task or screw up the run accidentally, and you&#8217;ll be snowed under with fixing your&nbsp;database.</p>
<p>Those tasks are easily done with bash, which is the first step to full automation. Following tasks are perfect candidates to be implemented as bash&nbsp;scripts:</p>
<ul>
<li>full backups (both creation and&nbsp;removal)</li>
<li><span class="caps">WAL</span> backups (both creation and&nbsp;removal)</li>
<li>vacuum</li>
<li>pgBadger log analysis (both creation and&nbsp;removal)</li>
<li>log maintenance (if you don&#8217;t use log&nbsp;rotate)</li>
</ul>
<!-- -->

<p>Full backup creation is just one example of how powerful bash can&nbsp;be.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># @author: Michal Zimmermann &amp;lt;michal.zimmermann@clevermaps.cz&amp;gt;</span>
<span class="c1"># Creates base backup.</span>

<span class="nv">CUR_DIR</span><span class="o">=</span><span class="k">$(</span>dirname <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">&quot;</span><span class="k">)</span>
<span class="k">if</span> <span class="o">[[</span> ! -f <span class="si">${</span><span class="nv">CUR_DIR</span><span class="si">}</span>/pgsql-common.sh <span class="o">]]</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;pgsql-common.sh not found!&quot;</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>

<span class="nb">source</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">CUR_DIR</span><span class="si">}</span><span class="s2">/pgsql-common.sh&quot;</span>
<span class="nb">source</span> <span class="s2">&quot;</span><span class="nv">$CONFIG</span><span class="s2">&quot;</span>

<span class="k">if</span> <span class="o">[[</span> -d <span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span> <span class="o">]]</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span><span class="s2"> already exists and is not empty!&quot;</span>
    <span class="nb">exit</span> <span class="m">2</span>
<span class="k">fi</span>

pg_basebackup <span class="se">\</span>
    --pgdata<span class="o">=</span><span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span> <span class="se">\</span>
    --format<span class="o">=</span>plain <span class="se">\</span>
    --write-recovery-conf <span class="se">\</span>
    --wal-method<span class="o">=</span>stream <span class="se">\</span>
    --label<span class="o">=</span><span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span> <span class="se">\</span>
    --checkpoint<span class="o">=</span>fast <span class="se">\</span>
    --progress <span class="se">\</span>
    --verbose

<span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> -gt <span class="m">0</span> <span class="o">]]</span>
<span class="k">then</span>
    rm -rf <span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span>
    <span class="nb">echo</span> <span class="s2">&quot;pg_basebackup on </span><span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span><span class="s2"> failed!&quot;</span>
    <span class="nb">exit</span> <span class="m">3</span>
<span class="k">fi</span>

tar -czf <span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span>.tar.gz <span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span> <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> rm -rf <span class="si">${</span><span class="nv">CR_BASE_BACKUP_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span>
</pre></div>


<p>As you probably noticed, a <code>pgsql-common.sh</code> file is sourced at the beginning of the script. This script in turn just loads the proper config file that provides variables to other, devops, scripts. As you might need those variables in several of your scripts, it is a good idea to put their load to a separate&nbsp;file.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># @author: Michal Zimmermann &amp;lt;michal.zimmermann@clevermaps.cz&amp;gt;</span>
<span class="c1"># Sourced in pgsql-*.sh scripts.</span>

<span class="k">while</span> <span class="o">[[</span> <span class="nv">$#</span> <span class="p">&amp;</span>gt<span class="p">;</span> <span class="m">0</span> <span class="o">]]</span>
<span class="k">do</span>
    <span class="nv">key</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

    <span class="k">case</span> <span class="nv">$key</span> in
        -c<span class="p">|</span>--config<span class="o">)</span>
            <span class="nv">CONFIG</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$2</span><span class="s2">&quot;</span>
            <span class="nb">shift</span>
            <span class="p">;;</span>
        *<span class="o">)</span>
            <span class="nb">echo</span> <span class="s2">&quot;Usage: `basename </span><span class="nv">$0</span><span class="s2">` --config|-c [config_file]&quot;</span>
            <span class="nb">exit</span> <span class="m">1</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
    <span class="nb">shift</span>
<span class="k">done</span>
<span class="c1"># /Input parameters</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="nv">$CONFIG</span><span class="s2">&quot;</span> <span class="o">]]</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Config file is not set! See the script usage below.&quot;</span>
    <span class="nv">$0</span> *
    <span class="nb">exit</span> <span class="m">2</span>
<span class="k">fi</span>

<span class="k">if</span> <span class="o">[[</span> ! -f <span class="s2">&quot;</span><span class="nv">$CONFIG</span><span class="s2">&quot;</span> <span class="o">]]</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$CONFIG</span><span class="s2"> not found!&quot;</span>
    <span class="nb">exit</span> <span class="m">3</span>
<span class="k">fi</span>
</pre></div>


<p>A config file might remain as simple as&nbsp;this:</p>
<div class="highlight"><pre><span></span><span class="c1"># Base backup location</span>
<span class="nb">export</span> <span class="nv">CR_BASE_BACKUP_DIR</span><span class="o">=</span><span class="s2">&quot;/mnt/backup/symap/base/&quot;</span>
<span class="c1"># WAL backup location</span>
<span class="nb">export</span> <span class="nv">CR_WAL_BACKUP_DIR</span><span class="o">=</span><span class="s2">&quot;/mnt/backup/symap/wal&quot;</span>
<span class="c1"># PostgreSQL WAL location</span>
<span class="nb">export</span> <span class="nv">CR_PG_XLOG_DIR</span><span class="o">=</span><span class="s2">&quot;/var/lib/postgresql/10/symap/pg_wal&quot;</span>
<span class="nb">export</span> <span class="nv">CR_PG_LOG_DIR</span><span class="o">=</span><span class="s2">&quot;/var/lib/postgresql/10/symap/pg_log&quot;</span>
<span class="c1"># Base backup pattern (set to YYYYMMDD)</span>
<span class="nb">export</span> <span class="nv">CR_LABEL</span><span class="o">=</span>symap_<span class="k">$(</span>date +%Y%m%d<span class="k">)</span>
<span class="nb">export</span> <span class="nv">PGPORT</span><span class="o">=</span><span class="m">5432</span>
</pre></div>


<p>Another, likely the simplest, example is a vacuumdb&nbsp;task:</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># @author: Michal Zimmermann &amp;lt;michal.zimmermann@clevermaps.cz&amp;gt;</span>
<span class="c1"># Vacuums the whole database cluster running on a given port.</span>

<span class="k">while</span> <span class="o">[[</span> <span class="nv">$#</span> <span class="p">&amp;</span>gt<span class="p">;</span> <span class="m">0</span> <span class="o">]]</span>
<span class="k">do</span>
    <span class="nv">key</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

    <span class="k">case</span> <span class="nv">$key</span> in
        -p<span class="p">|</span>--port<span class="o">)</span>
            <span class="nv">PORT</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$2</span><span class="s2">&quot;</span>
            <span class="nb">shift</span>
            <span class="p">;;</span>
        *<span class="o">)</span>
            <span class="nb">echo</span> <span class="s2">&quot;Usage: `basename </span><span class="nv">$0</span><span class="s2">` --port|-p [port_number]&quot;</span>
            <span class="nb">exit</span> <span class="m">1</span>
            <span class="p">;;</span>
    <span class="k">esac</span>
    <span class="nb">shift</span>
<span class="k">done</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="nv">$PORT</span><span class="s2">&quot;</span> <span class="o">]]</span>
<span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Port not provided!&quot;</span>
    <span class="nv">$0</span> *
    <span class="nb">exit</span> <span class="m">2</span>
<span class="k">fi</span>

/usr/bin/vacuumdb -U postgres -p <span class="nv">$PORT</span> --all --full --analyze
</pre></div>


<h2>Tips</h2>
<ul>
<li>Always test your bash scripts before production deployment. Even a single line of code might lead to a very different, possibly unexpected,&nbsp;outcome.</li>
<li>Try to stay as defensive as possible. Imagine a variable did not get sourced properly. Is it going to blow your database? Trust me, I know what I am talking about (see the tweet&nbsp;below).</li>
</ul>
<blockquote class="twitter-tweet" data-lang="cs"><p lang="en" dir="ltr">that feeling when you blog about keeping your <a href="https://twitter.com/hashtag/postgresql?src=hash&amp;ref_src=twsrc%5Etfw">#postgresql</a> data safe and few days later you accidentally bzip all postgres-owned files <span class="caps">WHILE</span> the database is running with untested <a href="https://twitter.com/hashtag/bash?src=hash&amp;ref_src=twsrc%5Etfw">#bash</a> script. What a <a href="https://twitter.com/hashtag/tuesday?src=hash&amp;ref_src=twsrc%5Etfw">#tuesday</a>!</p>&mdash; Michal Zimmermann (@zimmicz) <a href="https://twitter.com/zimmicz/status/968546584567996416?ref_src=twsrc%5Etfw">27. února 2018</a></blockquote>

<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2>Pitfalls</h2>
<p>You do not want to run your bash scripts by hand. You probably do not want them to be run by cron. You want to run them with systemd. More on this next&nbsp;time.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2018/postgresql-backup-and-recovery-orchestration-recovery/" rel="bookmark" title="Permalink to PostgreSQL Backup and Recovery Orchestration: Recovery">PostgreSQL Backup and Recovery Orchestration:&nbsp;Recovery</a></h1>
    <aside><span>Feb 16, 2018</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p>PostgreSQL continuous backups are very powerful, if you know how to use them for recovery. There&#8217;s nothing else to do to be sure about that other than <strong>actually trying it</strong>. Personally, I see recovery as a single process with two possibly different&nbsp;outcomes:</p>
<ul>
<li>you&#8217;re recovering to the same state your cluster is/was in (because of a hardware failure, provider switch, &hellip;) - it&#8217;s more of a data migration, but you need your backup&nbsp;anyway</li>
<li>you&#8217;re doing a point-in-time-recovery (someone dropped the wrong table, data got corrupted,&nbsp;&hellip;)</li>
</ul>
<p>Both scenarios follow the same steps and differ slighty at the&nbsp;end.</p>
<ol>
<li>Stop the PostgreSQL&nbsp;cluster.</li>
<li>Copy the current <code>PGDATA_DIR</code> somewhere safe, just in case you screw&nbsp;up.</li>
<li>Replace the <code>PGDATA_DIR</code> with the full backup. If you start the cluster right away, it will boot to the last full backup state (in my case, missing a week of <span class="caps">WAL</span> segments&nbsp;tops).</li>
</ol>
<h2>General&nbsp;recovery</h2>
<p>In this case, you&#8217;re trying to recover as far as possible. With previous steps done succesfully, the next&nbsp;follow:</p>
<ul>
<li>Copy all archived <span class="caps">WAL</span> segments created after the last full backup to <code>PGDATA_DIR/pg_xlog</code>. These can be found with <code>find -newer</code> command run against the corresponding <code>.backup</code> file in your <code>wal-archive/u/p</code> directory.</li>
<li>If your full backup strategy includes <code>recovery.conf</code> file creation, you cane safely move it or remove&nbsp;it.</li>
<li>Start the database cluster again. It is going to boot to the last working&nbsp;state.</li>
</ul>
<p>If you&#8217;re about to migrate your data, you might be better off with simple <code>pg_dump</code>, <code>pg_dumpall</code> and <code>pg_restore</code> commands rather than using full backup/<span class="caps">WAL</span> segments&nbsp;combination.</p>
<h2>Point-in-time-recovery</h2>
<p>PostgreSQL&#8217;s <span class="caps">PITR</span> can help you restore your accidentally deleted/corrupted data. After the first three steps mentioned above, you should follow with&nbsp;these:</p>
<ul>
<li>Copy all archived segments created after the last full backup somewhere the PostgreSQL user can read them (<code>/your-wal-recovery-folder/</code> for&nbsp;example).</li>
<li>Set up the <code>recovery.conf</code> file properly. If you know something nasty happened at 2018-01-29 08:00:00, try to recover right to that point (or to any other, as <a href="https://www.postgresql.org/docs/9.6/static/recovery-target-settings.html">described in the documentation</a>).</li>
</ul>
<!-- -->

<div class="highlight"><pre><span></span><span class="nv">restore_command</span> <span class="o">=</span> <span class="s1">&#39;cp /your-wal-recovery-folder/%f &quot;%p&quot;&#39;</span>
<span class="nv">recovery_target_time</span> <span class="o">=</span> <span class="s1">&#39;2018-01-29 08:00:00&#39;</span>
</pre></div>


<ul>
<li>Start the database cluster again. It is going to boot to the last full backup and then play all the <span class="caps">WAL</span> segments until the recovery target. Depending on how many <span class="caps">WAL</span> segments are about to be used, this might take a&nbsp;while.</li>
</ul>
<h2>Pitfalls</h2>
<p>You don&#8217;t want to find yourself in the middle of the biggest database failure of the century just to find out your <strong>backups don&#8217;t work</strong>, and even if they did, you would have <strong>no idea how to use them</strong>. Or, even worse, there are no backups at all, because your <strong>backup strategy has been failing silently</strong> without a single notice for several&nbsp;months.</p>
<h2>Tips</h2>
<p>Try to recover from your backups once in a&nbsp;while.</p>
<p>I forget things and make mistakes. We all do. That&#8217;s why I built an ensemble that takes care of our database automatically. Nothing fancy, just a bunch of good old Bash scripts managed with systemd rathern than cron. Next time, I&#8217;d like to show you the code and walk you through our current&nbsp;setup.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2018/postgresql-backup-and-recovery-orchestration-wal-archiving/" rel="bookmark" title="Permalink to PostgreSQL Backup and Recovery Orchestration: WAL Archiving">PostgreSQL Backup and Recovery Orchestration: <span class="caps">WAL</span>&nbsp;Archiving</a></h1>
    <aside><span>Feb 12, 2018</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p>Just a very few of my day-to-day work tasks can be accomplished without PostgreSQL. For years I&#8217;ve been a (power) user of this wonderful relational database, knowing almost nothing about how its internals really work. Faced with the need to build a backup and recovery strategy, I&#8217;ve recently read up <em>a lot</em> on this&nbsp;topic.</p>
<p>As I don&#8217;t find it very odd for a <span class="caps">GIS</span> person to be given such an extraordinary task (nobody wants to lose the priceless spatial data, right?), I hope this series might shed light on how to prepare and manage the backup/recovery process to those, who are up to such a task. I won&#8217;t be discussing backup strategies based on <code>pg_backup</code> tool, as those don&#8217;t offer neither continuous archivation, nor point-in-time-recovery (<span class="caps">PITR</span>) - those two features disqualifies it as <a href="https://www.clevermaps.cz">CleverMaps</a> production backup&nbsp;strategy.</p>
<p><strong>That leaves us with taking periodic base backups combined with continuous <span class="caps">WAL</span> archivation, as described&nbsp;below.</strong></p>
<h2>Taking base&nbsp;backups</h2>
<p>Archived <span class="caps">WAL</span> segments are worthless without a base backup they can be run on. It&#8217;s crucial to have consistent, periodic base backups to keep your data&nbsp;safe.</p>
<p><a href="https://www.postgresql.org/docs/current/static/app-pgbasebackup.html"><code>pg_basebackup</code></a> takes base backup of PostgreSQL cluster. Nothing fancy. Gzipping the output folder once the backup is done is definitely a good&nbsp;idea.</p>
<div class="highlight"><pre><span></span>pg_basebackup <span class="se">\</span>
    --pgdata<span class="o">=</span>/mnt/backup/base/backup_number <span class="se">\</span>
    --format<span class="o">=</span>plain <span class="se">\</span>
    --write-recovery-conf <span class="se">\</span>
    --xlog-method<span class="o">=</span>stream <span class="se">\</span>
    --label<span class="o">=</span><span class="si">${</span><span class="nv">CR_LABEL</span><span class="si">}</span> <span class="se">\</span>
    --checkpoint<span class="o">=</span>fast <span class="se">\</span>
    --progress <span class="se">\</span>
    --verbose
</pre></div>


<p>In our current environment, we take a base backup of each of our clusters once a&nbsp;week.</p>
<h2><span class="caps">WAL</span> archiving&nbsp;configuration</h2>
<p>To properly set <span class="caps">WAL</span> archiving, several <code>postgresql.conf</code> settings has to be&nbsp;adjusted:</p>
<ul>
<li><code>wal_level = replica</code></li>
<li><code>archive_mode = on</code></li>
<li><code>archive_command = test ! -f /backup/wal/%f &amp;&amp; cp %p /backup/wal/%f</code></li>
</ul>
<p>Setting <code>wal_level</code> to <code>replica</code> writes enough information for <span class="caps">WAL</span> archiving. Turning on <code>archive_mode</code> will run <code>archive_command</code> each time a <span class="caps">WAL</span> segment is completed. <code>archive_command</code> might be anything from simple <code>cp</code> to <code>rsync</code> or <code>aws s3 cp</code> commands. It is absolutely critical that the command returns <strong>non-zero exit code</strong> in case of failure (including when a file with the same name already exists in your backup&nbsp;folder).</p>
<p>That&#8217;s it, after reloading PostgreSQL service, new <span class="caps">WAL</span> files should be copied to <code>/backup/wal</code> directory. The PostgreSQL process user (<code>postgres</code> usually) has to be able to write to the&nbsp;location.</p>
<h3>Pitfalls</h3>
<ul>
<li>If <code>archive_command</code> fails, <span class="caps">WAL</span> segment remains on your database drive. If it keeps failing long enough, you&#8217;ll run out of space and the database will&nbsp;crash.</li>
<li>If the backup location fills up, the above-mentioned happens as&nbsp;well.</li>
<li>If you lose or corrupt any of the archived <span class="caps">WAL</span> segments, you won&#8217;t be able to pass through. That&#8217;s why you want to be sure that your <code>archive_command</code> actually does what you think it&nbsp;does.</li>
</ul>
<h3>Tips</h3>
<p>It might be a real <span class="caps">PITA</span> (fiddling around <span class="caps">WAL</span> segments included) to start a crashed database cluster with no space left. Keeping a dummy file in your <code>pg_xlog</code> location might save you a lot of trouble. Create one with following command. If you run out of space, remove this file and you get 300 <span class="caps">MB</span> for free. Don&#8217;t forget to recreate it after you start the&nbsp;cluster.</p>
<div class="highlight"><pre><span></span>dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/path_to_your_database_cluster/pg_xlog/DO_NOT_MOVE_THIS_FILE <span class="nv">bs</span><span class="o">=</span>1MB <span class="nv">count</span><span class="o">=</span><span class="m">300</span>
</pre></div>


<p>There&#8217;s no need to keep archived <span class="caps">WAL</span> segments forever. They&#8217;re only needed until you take another base backup. Again, deleting <span class="caps">WAL</span> segments manually (or using <code>find ! -newer previous_base_backup.tar.gz</code>) might lead to accidental corruption of your backups. It&#8217;s much safer to use <a href="https://www.postgresql.org/docs/9.6/static/pgarchivecleanup.html"><code>pg_archivecleanup</code></a> pointed to your <span class="caps">WAL</span> backup folder, referencing the last <strong>sucessful</strong> full backup. Below is the script we use to keep our <span class="caps">WAL</span> backup folder of reasonable size, keeping the last three full&nbsp;backups.</p>
<div class="highlight"><pre><span></span><span class="c1"># Find base_backup files not older than 3 weeks</span>
<span class="c1"># Sort by date</span>
<span class="c1"># Use the oldest one as a reference</span>
<span class="nv">OLDEST_BASE_BACKUP</span><span class="o">=</span><span class="k">$(</span>basename <span class="k">$(</span>find <span class="si">${</span><span class="nv">CR_WAL_BACKUP_DIR</span><span class="si">}</span>/u/p/ -type f -iname <span class="s2">&quot;*.backup&quot;</span> -mtime -21 -print0 <span class="p">|</span> <span class="se">\</span>
xargs -0 ls -t <span class="p">|</span> <span class="se">\</span>
tail -n <span class="m">1</span><span class="k">))</span>

<span class="c1"># Find all subfolders</span>
<span class="c1"># Except the u/p backup subfolder</span>
<span class="c1"># Execute pg_archivecleanup for each of the subfolders</span>
find <span class="nv">$CR_WAL_BACKUP_DIR</span> <span class="se">\</span>
    -type d <span class="se">\</span>
    -not -path <span class="s2">&quot;</span><span class="si">${</span><span class="nv">CR_WAL_BACKUP_DIR</span><span class="si">}</span><span class="s2">u*&quot;</span> <span class="se">\</span>
    -exec pg_archivecleanup -d <span class="o">{}</span> <span class="nv">$OLDEST_BASE_BACKUP</span> <span class="se">\;</span>
</pre></div>


<p>Functional backups are crucial part of a solid backup/recovery system. They&#8217;re still just one half of that system, though. <strong>If not tested thoroughly</strong>, they&#8217;re even less than that. More on testing backups and recovering from failures next&nbsp;time.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2015/installing-postgis-22-with-sfcgal-on-ubuntu-based-os/" rel="bookmark" title="Permalink to Installing PostGIS 2.2 with SFCGAL on Ubuntu-based OS">Installing PostGIS 2.2 with <span class="caps">SFCGAL</span> on Ubuntu-based <span class="caps">OS</span></a></h1>
    <aside><span>Oct 29, 2015</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/development.html">development</a></span>
    </aside>
    <p>I&#8217;ve seen a bunch of questions on <span class="caps">GIS</span> StackExchange recently related to <a href="http://sfcgal.org/"><span class="caps">SFCGAL</span></a> extension for <a href="http://postgis.net">PostGIS 2.2</a>. Great news are it can be installed with one simple query <code>CREATE EXTENSION postgis_sfcgal</code>. Not so great news are you have to compile it from source for Ubuntu-based <span class="caps">OS</span> (14.04) as recent versions of required packages are not available in the&nbsp;repositories.</p>
<p>I tested my solution on elementary <span class="caps">OS</span> 0.3.1 based on Ubuntu 14.04. <strong>And it works!</strong> It installs PostgreSQL 9.4 from repositories together with <span class="caps">GDAL</span> and <span class="caps">GEOS</span> and some other libs PostGIS depends on. PostGIS itself, <span class="caps">CGAL</span>, Boost, <span class="caps">MPFR</span> and <span class="caps">GMP</span> are built from&nbsp;source.</p>
<p>Here comes the code (commented where&nbsp;needed).</p>
<div class="highlight"><pre><span></span>sudo -i
<span class="nb">echo</span> <span class="s2">&quot;deb http://apt.postgresql.org/pub/repos/apt/ trusty-pgdg main&quot;</span> <span class="p">|</span> tee -a /etc/apt/sources.list
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc <span class="p">|</span> sudo apt-key add -
apt-get update
apt-get install -y postgresql-9.4 <span class="se">\</span>
    postgresql-client-9.4 <span class="se">\</span>
    postgresql-contrib-9.4 <span class="se">\</span>
    libpq-dev <span class="se">\</span>
    postgresql-server-dev-9.4 <span class="se">\</span>
    build-essential <span class="se">\</span>
    libgeos-c1 <span class="se">\</span>
    libgdal-dev <span class="se">\</span>
    libproj-dev <span class="se">\</span>
    libjson0-dev <span class="se">\</span>
    libxml2-dev <span class="se">\</span>
    libxml2-utils <span class="se">\</span>
    xsltproc <span class="se">\</span>
    docbook-xsl <span class="se">\</span>
    docbook-mathml <span class="se">\</span>
    cmake <span class="se">\</span>
    gcc <span class="se">\</span>
    m4 <span class="se">\</span>
    icu-devtools

<span class="nb">exit</span> <span class="c1"># leave root otherwise postgis will choke</span>

<span class="nb">cd</span> /tmp
touch download.txt
cat <span class="p">&amp;</span>lt<span class="p">;&amp;</span>lt<span class="p">;</span>EOT <span class="p">&amp;</span>gt<span class="p">;&amp;</span>gt<span class="p">;</span> download.txt
https://gmplib.org/download/gmp/gmp-6.0.0a.tar.bz2
https://github.com/Oslandia/SFCGAL/archive/v1.2.0.tar.gz
http://www.mpfr.org/mpfr-current/mpfr-3.1.3.tar.gz
http://downloads.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gz
https://github.com/CGAL/cgal/archive/releases/CGAL-4.6.3.tar.gz
http://download.osgeo.org/postgis/source/postgis-2.2.0.tar.gz

EOT

cat download.txt <span class="p">|</span> xargs -n <span class="m">1</span> -P <span class="m">8</span> wget <span class="c1"># make wget a little bit faster</span>

tar xjf gmp-6.0.0a.tar.bz2
tar xzf mpfr-3.1.3.tar.gz
tar xzf v1.2.0.tar.gz
tar xzf boost_1_59_0.tar.gz
tar xzf CGAL-4.6.3.tar.gz
tar xzf postgis-2.2.0.tar.gz

<span class="nv">CORES</span><span class="o">=</span><span class="k">$(</span>nproc<span class="k">)</span>

<span class="k">if</span> <span class="o">[[</span> <span class="nv">$CORES</span> <span class="p">&amp;</span>gt<span class="p">;</span> <span class="m">1</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CORES</span><span class="o">=</span><span class="k">$(</span>expr <span class="nv">$CORES</span> - <span class="m">1</span><span class="k">)</span> <span class="c1"># be nice to your PC</span>
<span class="k">fi</span>

<span class="nb">cd</span> gmp-6.0.0
./configure <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make -j <span class="nv">$CORES</span> <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> mpfr-3.1.3
./configure <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make -j <span class="nv">$CORES</span> <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> boost_1_59_0
./bootstrap.sh --prefix<span class="o">=</span>/usr/local --with-libraries<span class="o">=</span>all <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> sudo ./b2 install <span class="c1"># there might be some warnings along the way, don&#39;t panic</span>
<span class="nb">echo</span> <span class="s2">&quot;/usr/local/lib&quot;</span> <span class="p">|</span> sudo tee /etc/ld.so.conf.d/boost.conf
sudo ldconfig

<span class="nb">cd</span> ..
<span class="nb">cd</span> cgal-releases-CGAL-4.6.3
cmake . <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make -j <span class="nv">$CORES</span> <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> SFCGAL-1.2.0/
cmake . <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make -j <span class="nv">$CORES</span> <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> postgis-2.2.0
./configure <span class="se">\</span>
    --with-geosconfig<span class="o">=</span>/usr/bin/geos-config <span class="se">\</span>
    --with-xml2config<span class="o">=</span>/usr/bin/xml2-config <span class="se">\</span>
    --with-projdir<span class="o">=</span>/usr/share/proj <span class="se">\</span>
    --with-libiconv<span class="o">=</span>/usr/bin <span class="se">\</span>
    --with-jsondir<span class="o">=</span>/usr/include/json <span class="se">\</span>
    --with-gdalconfig<span class="o">=</span>/usr/bin/gdal-config <span class="se">\</span>
    --with-raster <span class="se">\</span>
    --with-topology <span class="se">\</span>
    --with-sfcgal<span class="o">=</span>/usr/local/bin/sfcgal-config <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> <span class="se">\</span>
make <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make cheatsheets <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> sudo make install <span class="c1"># deliberately one CPU only</span>

sudo -u postgres psql
sudo -u postgres createdb spatial_template
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;CREATE EXTENSION postgis;&quot;</span>
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;CREATE EXTENSION postgis_topology;&quot;</span>
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;CREATE EXTENSION postgis_sfcgal;&quot;</span>
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;SELECT postgis_full_version();&quot;</span>
</pre></div>
</article>
<aside id="pagination">
            <a href="https://www.zimmi.cz/posts/tag/linux2.html">Next page &raquo;</a>
</aside>    </main>
    <footer>
        Written by <a href="//www.zimmi.cz">Michal Zimmermann</a>.
        Proudly powered by <a href="//getpelican.com/">Pelican</a>,
        which takes great advantage of <a href="//python.org">Python</a>.
    </footer>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-43432739-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-43432739-2');
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NW8R37N');</script>
<!-- End Google Tag Manager -->
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NW8R37N"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
</body>
</html>